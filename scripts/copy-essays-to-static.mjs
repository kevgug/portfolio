import fs from "fs";
import path from "path";
import dotenv from "dotenv";
import matter from "gray-matter";

// Load environment variables
dotenv.config();

const essaysDir = process.env.ESSAYS_DIR;
if (!essaysDir) {
  throw new Error(
    "ESSAYS_DIR environment variable is not set. Please create a .env file with ESSAYS_DIR=/path/to/essays",
  );
}
const staticEssaysDir = path.resolve(process.cwd(), "static/essays");
const staticAssetsEssaysDir = path.resolve(
  process.cwd(),
  "static/assets/essays",
);

// Clear and recreate directories to ensure clean state
if (fs.existsSync(staticEssaysDir)) {
  fs.rmSync(staticEssaysDir, { recursive: true, force: true });
}
fs.mkdirSync(staticEssaysDir, { recursive: true });

if (fs.existsSync(staticAssetsEssaysDir)) {
  fs.rmSync(staticAssetsEssaysDir, { recursive: true, force: true });
}
fs.mkdirSync(staticAssetsEssaysDir, { recursive: true });

// Copy markdown files
const isProduction = process.env.NODE_ENV === "production";
const mdFiles = fs.readdirSync(essaysDir).filter((file) =>
  file.endsWith(".md")
);

console.log(`Copying essay markdown files...`);
let copiedCount = 0;
let skippedCount = 0;

mdFiles.forEach((file) => {
  const srcPath = path.join(essaysDir, file);

  // Check frontmatter for publish status
  const fileContents = fs.readFileSync(srcPath, "utf8");
  const { data } = matter(fileContents);

  // Skip unpublished essays in production
  if (isProduction && data.publish === false) {
    console.log(`  ⊗ ${file} (unpublished, skipped)`);
    skippedCount++;
    return;
  }

  const destPath = path.join(staticEssaysDir, file);
  fs.copyFileSync(srcPath, destPath);
  console.log(`  ✓ ${file}`);
  copiedCount++;
});

console.log(`\nCopied ${copiedCount} essays, skipped ${skippedCount}`);

// Copy assets directory if it exists (1:1 copy)
const assetsDir = path.join(essaysDir, "assets");
if (fs.existsSync(assetsDir)) {
  console.log("Copying essay assets...");

  const copyRecursive = (src, dest) => {
    const entries = fs.readdirSync(src, { withFileTypes: true });

    for (const entry of entries) {
      const srcPath = path.join(src, entry.name);
      const destPath = path.join(dest, entry.name);

      if (entry.isDirectory()) {
        if (!fs.existsSync(destPath)) {
          fs.mkdirSync(destPath, { recursive: true });
        }
        copyRecursive(srcPath, destPath);
      } else {
        fs.copyFileSync(srcPath, destPath);
      }
    }
  };

  // Simple 1:1 recursive copy of the entire assets directory
  copyRecursive(assetsDir, staticAssetsEssaysDir);
  console.log("  ✓ Assets copied");
}

console.log("\n✅ Essays copied to static/essays");

// Generate index.json
console.log("Generating essays/index.json...");
const mdFilesForIndex = fs
  .readdirSync(staticEssaysDir)
  .filter((file) => file.endsWith(".md"));

let essays = mdFilesForIndex.map((file) => {
  const filePath = path.join(staticEssaysDir, file);
  const fileContents = fs.readFileSync(filePath, "utf8");
  const { data } = matter(fileContents);

  return {
    slug: file.replace(/\.md$/, ""),
    title: data.title,
    date: data.date,
    publish: data.publish,
  };
});

if (isProduction) {
  essays = essays.filter((essay) => essay.publish);
}

essays = essays.sort((a, b) => new Date(b.date) - new Date(a.date));

const indexPath = path.join(staticEssaysDir, "index.json");
fs.writeFileSync(indexPath, JSON.stringify(essays, null, 2));
console.log("  ✓ Generated index.json");

// Trigger browser reload by updating a TypeScript file that Vite watches
const reloadTriggerPath = path.resolve(
  process.cwd(),
  "src/lib/essays-reload.ts",
);
const reloadContent =
  `// This file is auto-generated by copy-essays-to-static.mjs
// It triggers Vite HMR when essays are updated
export const ESSAYS_LAST_UPDATE = ${Date.now()};
`;
fs.writeFileSync(reloadTriggerPath, reloadContent, "utf8");
console.log("  ✓ Triggered reload");
